const needle = require('needle')    // http client
const app = require('../../app')    // expressjs app
const fse = require('fs-extra')     // wrapper around node's fs package with added utility functions
const path = require('path')        // simple path utility functions
const EventSource = require('eventsource')  // nodejs implementation of a Server-Sent Events client
const stoppable = require('stoppable') // greatly simplifies the process of stopping the expressjs server
const {getAllFileMetadata, getFileMetadata, STORAGE_DIR, sseClientHandler} = require('./storage.helpers')



async function getFileContentsViaAPI(filename) {
    // https://www.npmjs.com/package/needle#user-content-response-options
    // this function is to get the raw contents of the file via the API, so any parsing will occur later
    return needle('GET', u(`/api/download/${filename}`), {parse_response: false}).then(res => {return res.body})
}

function getFileContentsViaFileSystem(filepath){
    return fse.readFileSync(
        filepath, 
        {encoding: "utf-8"}
    )
}

// helper function to create the full url path
const u = (path) => process.env.BACKEND_URL + path

const expectedFileMetadataObjPattern = {
    "fileCategory": expect.any(String),
    "filename": expect.any(String),
    "filesize": expect.any(Number),
    "staticURL": expect.stringMatching(new RegExp("https?://")), 
    "uploadTimeEpochMs": expect.any(Number)
}
const initialFilenames = ["img1.png", "img2.jpg","setup-env-files.js","text-upload_1686708193.txt"]    

var httpServer


beforeAll(async () => {
    // create and empty test storage dir
    // copy files from test artifacts       
    fse.emptyDirSync(STORAGE_DIR)
    initialFilenames.forEach((filename) => {
        fse.copyFileSync(
            path.join(process.env.TEST_ARTIFACTS_DIR, filename),
            path.join(STORAGE_DIR, filename)
        )
    })

    // starts the server
    httpServer = stoppable(
        app.listen(process.env.BACKEND_PORT, process.env.PRIVATE_IP_ADDR, () => {
            console.log(`Backend test server started at ${process.env.BACKEND_URL}`);
        }), 0
    )

    jest.spyOn(sseClientHandler, 'sendFileEventToAll')
    //jest.spyOn(sseClientHandler, 'addNewClient')
})

afterAll(() => {
    //testSSEClient1.close()
    httpServer.stop()
})  




describe('The initial test files have valid metadata', () => {
    test('that all test files exist', async () => {
        expect(getAllFileMetadata()).toHaveLength(initialFilenames.length)
    })
    
    test('that a test file has correctly formatted metadata', async () => {
        expect(getFileMetadata(["img1.png"]))
        .toEqual([expectedFileMetadataObjPattern])
    })
})

describe("downloading file", () => {
    test("the stored file has the same contents when retrieved via the API", async () => {
        const filename = "text-upload_1686708193.txt"
        const filepath = path.join(STORAGE_DIR, filename)
        expect(await getFileContentsViaAPI(filename))
        .toEqual(getFileContentsViaFileSystem(filepath))
    })
})


describe("uploads the text content and file successfully", () => {
    const expectedTextData = "<<expected text file contents>>"
    const jsonFilename = "upload-test-1.json"

    test('upload endpoint returns an OK response', async () => {
        postData = {
            'uploaded_text': expectedTextData,
            'uploaded_files': {
                file: path.join(process.env.TEST_ARTIFACTS_DIR, jsonFilename),
                content_type: 'application/json'
            }
        }

        await needle("POST", u("/api/upload"), postData, {multipart: true})
            .then((res) => expect(res.statusCode).toEqual(200))
    })

    test("text data was stored correctly and is retrievable via the API", async () => {
        //      the filename is autogenerated, so we find the most recent file 
        //      with the format "text-upload_EPOCHDATE" and validate its contents
        
        const currentAllFileMetadata = getAllFileMetadata()
        const textUploadFilename = currentAllFileMetadata
                                                .sort((a,b) => b.uploadTimeEpochMs - a.uploadTimeEpochMs)
                                                .at(0)
                                                .filename
        const textUploadFilepath = path.join(STORAGE_DIR, textUploadFilename)
        expect(await(getFileContentsViaAPI(textUploadFilename)))
            .toEqual(getFileContentsViaFileSystem(textUploadFilepath))
    })

     // text data was uploaded and is retrievable
    test("uploaded file was stored correctly and is retrievable via the API", async () => {
        // uploaded file was uploaded and is retrievable
        const jsonFilepath = path.join(STORAGE_DIR, jsonFilename)
        expect(await getFileContentsViaAPI(jsonFilename))
            .toEqual(getFileContentsViaFileSystem(jsonFilepath))
    })

    test("the upload metadata was broadcast by the sseClientHandler", () => {
        expect(sseClientHandler.sendFileEventToAll).toHaveBeenLastCalledWith({
            type: 'uploaded', 
            uploadedFileMetadataArr: expect.any(Array)
        })
    })
  
})


describe("deleting a file", () => {
    const filename = "img2.jpg"
    const filepath = path.join(STORAGE_DIR, filename)

    test("the file exists at the beginning of the test", () => {
        expect(fse.pathExistsSync(filepath)).toBe(true)
    })

    test("delete endpoint returns an OK response", async () => {
        await needle('DELETE', u('/api/delete'), {"filename": filename }, { json: true })
        .then(res => expect(res.statusCode).toEqual(200))
    })

    test("file no longer exists", () => {
        expect(fse.pathExistsSync(filepath)).toBe(false)
    })
    test("the delete metadata was broadcast by the sseClientHandler", () => {
        expect(sseClientHandler.sendFileEventToAll).toHaveBeenLastCalledWith({ 
            type: 'deleted', 
            deletedFilename: expect.any(String)
        })
    })
})

describe("SSE Client connection successful", (teardownIsDone) => {
    var testSSEClient1
    var messageData

    beforeAll((setupIsDone) => {
        testSSEClient1 = new EventSource(u("/api/file-events"))
        testSSEClient1.onmessage = (event) => {messageData = JSON.parse(event.data)}
        testSSEClient1.onopen = () => setupIsDone()
    })
    
    afterAll(() => {
        testSSEClient1.addEventListener('close', () => teardownIsDone()) 
        testSSEClient1.close()
    })

    test("new SSE client receives the reloaded event without issue", async () => {
        expect(messageData.type).toEqual("reloaded")
        // 4 initial files + 2 uploaded - 1 deleted
        expect(messageData.fileMetadataArr.length).toEqual(5)
    })

    


})

